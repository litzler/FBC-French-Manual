<html>
<head>
<title>Type Aliases</title>
<link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
<div id="fb_body_wrapper">
<div id="fb_tab">
<div id="fb_tab_l">Alias de type</div>
<div id="fb_tab_r">&nbsp;<img src="images/fblogo_mini.gif" /></div> 
</div> 
<div id="fb_pg_wrapper">
<div id="fb_pg_body">
	D'autres noms pour les types de variable ou d'objet<br \>
<br \>
<b><a href="#OVERVIEW">Vue d'ensemble</a></b><br \>
<b><a href="#DECL">D&eacute;claration</a></b><br \>
<b><a href="#OVERLOAD">R&eacute;solution de la surcharge</a></b><br \>
<b><a href="#PROCPTRPTR">Pointeurs de pointeurs de proc&eacute;dure</a></b><br \>
<b><a href="#TYPEFORWARD">Transmission de type</a></b><br \>
<b><a href="#INCTYPES">Types incomplets</a></b><br \>
<br \>
<a name="OVERVIEW"></a><div class="fb_sect_title">Vue d'ensemble</div><div class="fb_sect_cont"><br \>
Les alias de type sont d'autres noms pour un type. Ils peuvent &ecirc;tre utilis&eacute;s pour faciliter un changement en masse d'un type &agrave; un autre, en diminuant la frappe ou rendre possible une d&eacute;pendance circulaire.<br \>
<br \>
<a name="DECL"></a></div><div class="fb_sect_title">D&eacute;claration</div><div class="fb_sect_cont"><br \>
Les alias de type sont d&eacute;clar&eacute;s en utilisant le mot-cl&eacute; <tt><a href="KeyPgTypeAlias.html">Type</a></tt> un peu comme la d&eacute;claration de variables ou d'objects avec <a href="KeyPgExtern.html">Extern</a> ou <a href="KeyPgDim.html">Dim</a>.<br \>
<br \>
L'exemple suivant d&eacute;clare un alias de type <tt><a href="KeyPgSingle.html">Single</a></tt> appel&eacute; "<tt><i>float</i></tt>", une proc&eacute;dure et d&eacute;finit et initialise deux variables de ce type:<br \>
<br \>
<tt><div class="freebasic">
<span class="key">Type</span>&nbsp;<span class="wrd">float</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Single</span><br />
<br />
<span class="key">Declare</span>&nbsp;<span class="key">Function</span>&nbsp;<span class="wrd">add</span>&nbsp;<span class="oth">(</span><span class="wrd">a</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">float</span><span class="oth">,</span>&nbsp;<span class="wrd">b</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">float</span><span class="oth">)</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">float</span><br />
<br />
<span class="key">Dim</span>&nbsp;<span class="wrd">foo</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">float</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="num">1.23</span><br />
<span class="key">Dim</span>&nbsp;<span class="wrd">bar</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">float</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="oth">-</span><span class="num">4.56</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></tt><br />
<br \>
Les alias de type de pointeur de proc&eacute;dure sont d&eacute;clar&eacute;s de la m&ecirc;me fa&ccedil;on, comme le montre l'exemple suivant:<br \>
<br \>
<tt><div class="freebasic">
<span class="key">Declare</span>&nbsp;<span class="key">Function</span>&nbsp;<span class="wrd">f</span>&nbsp;<span class="oth">(</span><span class="key">ByRef</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">String</span><span class="oth">)</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span><br />
<br />
<span class="key">Type</span>&nbsp;<span class="wrd">func_t</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Function</span>&nbsp;<span class="oth">(</span><span class="key">ByRef</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">String</span><span class="oth">)</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span><br />
<br />
<span class="key">Dim</span>&nbsp;<span class="wrd">func</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">func_t</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="oth">@</span><span class="wrd">f</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
<span class="key">Function</span>&nbsp;<span class="wrd">f</span>&nbsp;<span class="oth">(</span><span class="key">ByRef</span>&nbsp;<span class="wrd">arg</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">String</span><span class="oth">)</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="key">Function</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="key">CInt</span><span class="oth">(</span><span class="wrd">arg</span><span class="oth">)</span><br />
<span class="key">End</span>&nbsp;<span class="key">Function</span><br />
</div></tt><br />
<br \>
<a name="OVERLOAD"></a></div><div class="fb_sect_title">R&eacute;solution de la surcharge</div><div class="fb_sect_cont"><br \>
Les alias de type ne sont que cela - des alias. A toutes fins utiles, un alias de type <b>est</b> du type qu'il remplace. Ainsi dans le cas o&ugrave; la r&eacute;solution de la surcharge de proc&eacute;dure est concern&eacute;e, une proc&eacute;dure d&eacute;clar&eacute;e avec un param&egrave;tre de type "<tt><i>alias_vers_T</i></tt>" est la m&ecirc;me qu'une proc&eacute;dure d&eacute;clar&eacute;e avec un param&egrave;tre de type "<tt><i>T</i></tt>" (la m&ecirc;me chose s'applique ainsi &agrave; la surcharge membres des proc&eacute;dures).<br \>
<br \>
En d'autres termes, c'est une erreur -double d&eacute;finition- de d&eacute;clarer une proc&eacute;dure o&ugrave; les param&egrave;tres ne diff&egrave;rent que par un type et son alias, comme l'exemple suivant le montre:<br \>
<br \>
<tt><div class="freebasic">
<span class="key">Type</span>&nbsp;<span class="wrd">float</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Single</span><br />
<br />
<span class="key">Declare</span>&nbsp;<span class="key">Sub</span>&nbsp;<span class="wrd">f</span>&nbsp;<span class="key">Overload</span>&nbsp;<span class="oth">(</span><span class="wrd">a</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Single</span><span class="oth">)</span><br />
<br />
<span class="com">''&nbsp;If&nbsp;uncommented,&nbsp;this&nbsp;will&nbsp;generate&nbsp;a&nbsp;duplicated&nbsp;definition&nbsp;error</span><br />
<span class="com">''&nbsp;Declare&nbsp;Sub&nbsp;f&nbsp;(a&nbsp;As&nbsp;float)</span><br />
</div></tt><br />
<br \>
<a name="PROCPTRPTR"></a></div><div class="fb_sect_title">Pointeurs de pointeurs de proc&eacute;dure</div><div class="fb_sect_cont"><br \>
Les pointeurs de pointeurs de proc&eacute;dure sont comme n'importe quel autre type de pointeur, sauf qu'ils pointent vers des pointeurs de proc&eacute;dure. Parce que la syntaxe pour d&eacute;clarer des pointeurs de proc&eacute;dure ne permet pas de cr&eacute;er directement un pointeur sur pointeur de proc&eacute;dure, un alias de type est utilis&eacute;.<br \>
<br \>
L'exemple suivant d&eacute;clare un pointeur vers une de proc&eacute;dure retournant un pointeur d'entier, puis un pointeur vers un pointeur vers une de proc&eacute;dure retournant un entier:<br \>
<br \>
<tt><div class="freebasic">
<span class="key">Dim</span>&nbsp;<span class="wrd">pf</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Function</span><span class="oth">()</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span>&nbsp;<span class="key">Ptr</span><br />
<br />
<span class="key">Type</span>&nbsp;<span class="wrd">pf_t</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Function</span><span class="oth">()</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span><br />
<span class="key">Dim</span>&nbsp;<span class="wrd">ppf</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">pf_t</span>&nbsp;<span class="key">Ptr</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;</div></tt><br />
<br \>
<a name="TYPEFORWARD"></a></div><div class="fb_sect_title">Transmission de type</div><div class="fb_sect_cont"><br \>
Des alias de type peuvent &ecirc;tre avant le r&eacute;f&eacute;rencement: un alias peut faire r&eacute;f&eacute;rence &agrave; un autre type qui n'est pas encore enti&egrave;rement d&eacute;fini.<br \>
<br \>
<tt><div class="freebasic">
<span class="key">Type</span>&nbsp;<span class="wrd">foo</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">bar</span><br />
<br />
<span class="key">Type</span>&nbsp;<span class="wrd">sometype</span><br />
&nbsp;&nbsp;<span class="wrd">f</span>&nbsp;&nbsp;&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">foo</span>&nbsp;<span class="key">Ptr</span><br />
<span class="key">End</span>&nbsp;<span class="key">Type</span><br />
<br />
<span class="key">Type</span>&nbsp;<span class="wrd">bar</span><br />
&nbsp;&nbsp;<span class="wrd">st</span>&nbsp;&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">sometype</span><br />
&nbsp;&nbsp;<span class="wrd">a</span>&nbsp;&nbsp;&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span><br />
<span class="key">End</span>&nbsp;<span class="key">Type</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;</div></tt><br />
<br \>
En utilisant un alias de type et un r&eacute;f&eacute;rencement pr&eacute;coce permet des d&eacute;pendances circulaires entre les types.<br \>
<br \>
<tt><div class="freebasic">
<span class="key">Type</span>&nbsp;<span class="wrd">list</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">list_</span><br />
<br />
<span class="key">Type</span>&nbsp;<span class="wrd">listnode</span><br />
&nbsp;&nbsp;<span class="wrd">parent</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">list</span>&nbsp;<span class="key">Ptr</span><br />
&nbsp;&nbsp;<span class="wrd">text</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">String</span><br />
<span class="key">End</span>&nbsp;<span class="key">Type</span><br />
<br />
<span class="key">Type</span>&nbsp;<span class="wrd">list_</span><br />
&nbsp;&nbsp;<span class="wrd">first</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">listnode</span>&nbsp;<span class="key">Ptr</span><br />
&nbsp;&nbsp;<span class="wrd">count</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span><br />
<span class="key">End</span>&nbsp;<span class="key">Type</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;</div></tt><br />
<br \>
<a name="INCTYPES"></a></div><div class="fb_sect_title">Types incomplets</div><div class="fb_sect_cont"><br \>
 Un type est consid&eacute;r&eacute; comme incomplet jusqu'&agrave; ce que la taille de celui-ci (c'est le nombre d'octets qui lui sont n&eacute;cessaires en m&eacute;moire) soit connue ainsi que les positions de tous ses champs.  Il n'est pas possible d'allouer de l'espace m&eacute;moire pour un type incomplet.  Il n'est pas possible de d&eacute;clarer une variable ayant un type de donn&eacute;es incomplet, de passer un type incomplet comme param&egrave;tre ou d'acc&eacute;der aux membres d'un type incomplet.<br \>
<br \>
Toutefois, des pointeurs vers des types incomplets peuvent &ecirc;tre attribu&eacute;s, d&eacute;clar&eacute;s comme membres dans d'autres types ou pass&eacute;s comme param&egrave;tres &agrave; une proc&eacute;dure, d&egrave;s lors que la taille d'un pointeur est connue.<br \>
<br \>
<tt><div class="freebasic">
<span class="key">Type</span>&nbsp;<span class="wrd">sometype</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">sometype_</span><br />
<br />
<span class="com">''&nbsp;Not&nbsp;allowed&nbsp;since&nbsp;size&nbsp;of&nbsp;sometype&nbsp;is&nbsp;unknown</span><br />
<span class="com">''&nbsp;TYPE&nbsp;incomplete</span><br />
<span class="com">''&nbsp;&nbsp;&nbsp;a&nbsp;AS&nbsp;sometype</span><br />
<span class="com">''&nbsp;END&nbsp;TYPE</span><br />
<br />
<span class="com">''&nbsp;Allowed&nbsp;since&nbsp;size&nbsp;of&nbsp;a&nbsp;pointer&nbsp;is&nbsp;known</span><br />
<span class="key">Type</span>&nbsp;<span class="wrd">complete</span><br />
&nbsp;&nbsp;<span class="wrd">a</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">sometype</span>&nbsp;<span class="key">Ptr</span><br />
<span class="key">End</span>&nbsp;<span class="key">Type</span><br />
<span class="key">Dim</span>&nbsp;<span class="wrd">x</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">complete</span><br />
<br />
<span class="com">''&nbsp;Not&nbsp;allowed&nbsp;since&nbsp;size&nbsp;of&nbsp;sometype&nbsp;is&nbsp;still&nbsp;unknown</span><br />
<span class="com">''&nbsp;DIM&nbsp;size_sometype&nbsp;AS&nbsp;INTEGER&nbsp;=&nbsp;SIZEOF(&nbsp;sometype&nbsp;)</span><br />
<br />
<span class="com">''&nbsp;Complete&nbsp;the&nbsp;type</span><br />
<span class="key">Type</span>&nbsp;<span class="wrd">sometype_</span><br />
&nbsp;&nbsp;<span class="wrd">value</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span><br />
<span class="key">End</span>&nbsp;<span class="key">Type</span><br />
<br />
<span class="com">''&nbsp;Allowed&nbsp;since&nbsp;the&nbsp;types&nbsp;are&nbsp;now&nbsp;completed</span><br />
<span class="key">Dim</span>&nbsp;<span class="wrd">size_sometype</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="key">SizeOf</span><span class="oth">(</span>&nbsp;<span class="wrd">sometype</span>&nbsp;<span class="oth">)</span><br />
<br />
<span class="key">Type</span>&nbsp;<span class="wrd">completed</span><br />
&nbsp;&nbsp;<span class="wrd">a</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">sometype</span><br />
<span class="key">End</span>&nbsp;<span class="key">Type</span><br />
<br />
<span class="key">Dim</span>&nbsp;<span class="wrd">size_completed</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="key">SizeOf</span><span class="oth">(</span>&nbsp;<span class="wrd">completed</span>&nbsp;<span class="oth">)</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;</div></tt><br />
<br \>
<br \>
<br \>
   <br \>
</div>
</div>
</div> 
</div> 
</body>
</html>
