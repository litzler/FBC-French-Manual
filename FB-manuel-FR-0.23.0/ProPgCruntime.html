<html>
<head>
<title>C Standard Library Functions</title>
<link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
<div id="fb_body_wrapper">
<div id="fb_tab">
<div id="fb_tab_l">Fonctions biblioth&egrave;que C standard</div>
<div id="fb_tab_r">&nbsp;<img src="images/fblogo_mini.gif" /></div> 
</div> 
<div id="fb_pg_wrapper">
<div id="fb_pg_body">
	Ceci est une liste des prototypes de fonction dans la biblioth&egrave;que standard C dans l'ordre alphab&eacute;tique et une liste des prototypes group&eacute;s par fonctionnalit&eacute;. <br \>
<br \>
<b><a href="#ALPHA">Liste alphab&eacute;tique</a></b><br \>
<b><a href="#BUFFER">Manipulation de tampon</a></b><br \>
<b><a href="#CTYPE">Classification et conversion des caract&egrave;res</a></b><br \>
<b><a href="#DATA">Conversion de donn&eacute;es</a></b><br \>
<b><a href="#DIRS">Manipulation de r&eacute;pertoire</a></b><br \>
<b><a href="#FILES">Manipulation de fichiers</a></b><br \>
<b><a href="#STREAM">Flux E/S</a></b><br \>
<b><a href="#LOLEVIO">E/S bas niveau</a></b><br \>
<b><a href="#MATH">Math&eacute;matiques</a></b><br \>
<b><a href="#MEMORY">Allocation m&eacute;moire</a></b><br \>
<b><a href="#PROCESS">Contr&ocirc;le de processus</a></b><br \>
<b><a href="#SORTING">Recherche et Tri</a></b><br \>
<b><a href="#STRING">Manipulation de cha&icirc;nes</a></b><br \>
<b><a href="#TIME">Temps</a></b><br \>
<br \>
<div class="fb_sect_title">Description</div><div class="fb_sect_cont"><br \>
La colonne Commentaires contient une br&egrave;ve description de l'utilisation de la fonction. La liste n'est pas compl&egrave;te, La liste n'est pas compl&egrave;te, mais elle fournit des informations sur les grandes fonctions de la biblioth&egrave;que d'ex&eacute;cution C. Il convient, &agrave; tout le moins, d'indiquer quelles fonctions sont disponibles dans la biblioth&egrave;que standard C vous permettant de faire une enqu&ecirc;te plus approfondie sur celle en votre possession.  Certaines des fonctions de la biblioth&egrave;que C document&eacute;es ailleurs peuvent ne pas &ecirc;tre disponibles en FreeBasic.  V&eacute;rifiez le fichier d'inclusion appropri&eacute; pour plus d'informations. <br \>
<br \>
<b>Note:</b> Les prototypes suivants ne sont pas des prototypes officiels FreeBASIC (voir les fichiers include), toutefois, ils vous donneront suffisamment d'informations pour utiliser correctement les fonctions. <br \>
<br \>
La colonne Fichier &agrave; inclure contient le nom du fichier que vous devez inclure, en utilisant la directive <tt><a href="KeyPgInclude.html">#include</a></tt> au d&eacute;but de votre programme. Si vous n'incluez pas le fichier d'inclusion appropri&eacute;, soit le programme ne sera pas compil&eacute;, soit il sera apparemment compil&eacute; correctement, mais donnera des r&eacute;sultats incorrects lors de son ex&eacute;cution.  Tous les en-t&ecirc;tes d'ex&eacute;cution C sont situ&eacute;s dans le r&eacute;pertoire <tt>crt</tt>; Par exemple, si l'en-t&ecirc;te sp&eacute;cifi&eacute;e est <tt>math.bi</tt>, utilisez <tt>include "crt/math.bi"</tt> ou <tt>include "crt\math.bi"</tt>, juste <tt>include "crt.bi"</tt> inclura tous les autres.<br \>
<br \>
La colonne prototype contient les informations suivantes: <br \>
<ul><ul><li> Le nom de la fonction; <br \>
<li> Les param&egrave;tres requis pour la fonction entre parenth&egrave;ses, avec le type de donn&eacute;es des param&egrave;tres; <br \>
<li> Le type de donn&eacute;es de la valeur retourn&eacute;e par la fonction. <br \>
<br \>
</ul></ul>Par exemple <b><tt>atoi(a as zstring ptr) as integer</tt></b> signifie que la fonction <b><tt>atoi</tt></b> retourne une valeur de type <b>integer</b> et n&eacute;cessite un caract&egrave;re <b>zstring ptr</b> comme argument. <br \>
<br \>
<a name="ALPHA"></a></div><div class="fb_sect_title">Liste alphab&eacute;tique</div><div class="fb_sect_cont"><br \>
<br \>
<div class="fb_table"><table><tr><td>Nom</td><td>Prototype (avec param&egrave;tres)</td><td>Fichier Include</td><td>Commentaires</td></tr>
<tr><td>abs_</td><td>abs_(n as integer) as integer</td><td>stdlib.bi</td><td>Retourne la valeur absolue (c.a.d la valeur positive)</td></tr>
<tr><td>acos_</td><td>acos_(a as double) as double</td><td>math.bi</td><td>Retourne le cosinus inverse (angle en radians)</td></tr>
<tr><td>asin_</td><td>asin_(a as double) as double</td><td>math.bi</td><td>Retourne le sinus inverse (angle en radians)</td></tr>
<tr><td>atan_</td><td>atan_(a as double) as double</td><td>math.bi</td><td>Retourne la tangente inverse (angle en radians)</td></tr>
<tr><td>atan2_</td><td>atan2_(y as double, x as double) as double</td><td>math.bi</td><td>Retourne la tangente inverse (passe l'oppos&eacute; en y et l'adjacent en x)</td></tr>
<tr><td>atoi</td><td>atoi(s as zstring ptr) as integer</td><td>stdlib.bi</td><td>Convertit une cha&icirc;ne zstring de chiffres en un nombre de type entier.</td></tr>
<tr><td>atof</td><td>atof(s as zstring ptr) as double</td><td>stdlib.bi</td><td>Convertit une cha&icirc;ne zstring de chiffres en un nombre de type double.</td></tr>
<tr><td>calloc</td><td>calloc(NumElts as integer, EltSiz as integer) as any ptr</td><td>stdlib.bi</td><td>Alloue de la m&eacute;moire. Retourne un pointeur vers un tampon pour un tableau ayant NumElts &eacute;l&eacute;ments, chacun de EltSiz octets.</td></tr>
<tr><td>ceil</td><td>ceil(d as double) as double</td><td>math.bi</td><td>Retourne l'entier le plus proche au-dessus de la valeur pass&eacute;e.</td></tr>
<tr><td>clearerr</td><td>clearerr(s as FILE ptr)</td><td>stdio.bi</td><td>Efface les indicateurs d'erreur sur un flux fichier (lecture ou &eacute;criture).</td></tr>
<tr><td>cos_</td><td>cos_(ar as double) as double</td><td>math.bi</td><td>Retourne le cosinus d'un angle mesur&eacute; en radians.</td></tr>
<tr><td>cosh</td><td>cosh(x as double) as double</td><td>math.bi</td><td>Retourne le cosinus hyperbolique d'un angle mesur&eacute; en radians.</td></tr>
<tr><td>div</td><td>div(num as integer, denom as integer) as div_t</td><td>stdlib.bi</td><td>Retourne le quotient et le reste d'une division dans une structure de type div_t.</td></tr>
<tr><td>ecvt</td><td>ecvt(x as double) as zstring ptr</td><td>math.bi</td><td>Convertit un num&eacute;ro en une zstring.</td></tr>
<tr><td>exit_</td><td>exit_(status as integer)</td><td>stdlib.bi</td><td>Quitte le programme. Vide les tampons des fichiers ouverts et ferme tous les fichiers ouverts, et ex&eacute;cuter toutes les fonctions appel&eacute;es par atexit().</td></tr>
<tr><td>exp_</td><td>exp_(a as double) as double</td><td>math.bi</td><td>Retourne la valeur de e &eacute;lev&eacute;e &agrave; la puissance de l'argument (inverse du logarithme naturel).</td></tr>
<tr><td>fabs</td><td>fabs(d as double) as double</td><td>math.bi</td><td>Retourne la valeur absolue (c.a.d la valeur positive) d'un type double.</td></tr>
<tr><td>fclose</td><td>fclose(s as FILE ptr) as FILE ptr</td><td>stdio.bi</td><td>Ferme un fichier. Retourne 0 en cas de succ&egrave;s sinon EOF.</td></tr><tr>
<td>feof</td><td>feof(s as FILE ptr) as integer</td><td>stdio.bi</td><td>Retourne la valeur indicateur fin de fichier. (0 si pas EOF). L'indicateur s'effacera lui-m&ecirc;me mais il peut &ecirc;tre r&eacute;initialis&eacute;e par clearerr ().</td></tr>
<tr><td>ferror</td><td>ferror(s as FILE ptr) as integer</td><td>stdio.bi</td><td>Retourne l'indicateur d'erreur pour un flux (0 si aucune erreur). L'indicateur d'erreur est r&eacute;initialis&eacute; par clearerr () ou rewind ().</td></tr>
<tr><td>fflush</td><td>fflush(s as FILE ptr) as integer</td><td>stdio.bi</td><td>Vide (c.a.d supprime) un flux (utilisez stdin pour vider le flux &agrave; partir du clavier). Retourne 0 en cas de succ&egrave;s.</td></tr>
<tr><td>fgetc</td><td>fgetc(s as FILE ptr) as integer</td><td>stdio.bi</td><td>Saisie d'un seul caract&egrave;re (en ASCII) &agrave; partir d'un flux (stdin pour le clavier).</td></tr>
<tr><td>fgetpos</td><td>fgetpos(s as FILE ptr, c as fpos_t ptr) as integer</td><td>stdio.bi</td><td>Enregistre la position du pointeur de fichier sur flux s &agrave; l'endroit point&eacute; par c.</td></tr>
<tr><td>fgets</td><td>fgets(b as zstring ptr, n as integer, s as FILE ptr) as zstring ptr</td><td>stdio.bi</td><td>A partir du flux s lit jusqu'&agrave; n-1 caract&egrave;res dans le tampon b.</td></tr>
<tr><td>floor</td><td>floor(d as double) as double</td><td>math.bi</td><td>Retourne l'entier le plus proche en dessous de la valeur pass&eacute;e.</td></tr>
<tr><td>fmod</td><td>fmod(x as double, y as double) as double</td><td>math.bi</td><td>Calcule le reste de x divis&eacute; par y.</td></tr>
<tr><td>fopen</td><td>fopen(file as zstring ptr, mode as zstring ptr) as FILE ptr</td><td>stdio.bi</td><td>Ouvre un fichier. Passe le nom DOS du fichier et un code pour indiquer soit pour lire, &eacute;crire, ou ajouter. Les codes sont r pour lire, w pour &eacute;crire, + pour lire et &eacute;crire, a pour ajouter et b pour binaire.</td></tr>
<tr><td>fprintf</td><td>fprintf(s as FILE ptr, fmt as zstring ptr, ...) as integer</td><td>stdio.bi</td><td>Ecrit sur le flux s autant d'items qu'il y a des signes % simples dans fmt qui ont d'arguments correspondant dans la liste.</td></tr>
<tr><td>fputc</td><td>fputc(c as integer, s as FILE ptr) as integer</td><td>stdio.bi</td><td>Sortie d'un unique caract&egrave;re c sur le flux s</td></tr>
<tr><td>fputs</td><td>fputs(b as zstring ptr, s as FILE ptr) as integer</td><td>stdio.bi</td><td>Envoie le flux de caract&egrave;res dans b vers le flux s, retourne 0 si l'op&eacute;ration &eacute;choue.</td></tr>
<tr><td>fread</td><td>fread(buf as any ptr, b as size_t, c as size_t, s as FILE ptr) as integer</td><td>stdio.bi</td><td>Lit c items de donn&eacute;es de b octets de taille &agrave; partir du fichier s vers le tampon buf. Retourne le nombre d'items r&eacute;ellement lus.</td></tr>
<tr><td>free</td><td>free(p as any ptr)</td><td>stdlib.bi</td><td>Lib&egrave;re la m&eacute;moire allou&eacute;e pour un pointeur p pour activer cette m&eacute;moire et la rendre utilisable.</td></tr>
<tr><td>freopen</td><td>freopen(file as zstring ptr, mode as zstring ptr, s as FILE ptr) as FILE ptr</td><td>stdio.bi</td><td>Ouvre un fichier pour rediriger un flux. par ex. freopen("myfile", "w", stdout) redirigera la sortie standard vers le fichier ouvert "myfile".</td></tr>
<tr><td>frexp</td><td>frexp(x as double, p as integer ptr) as double</td><td>math.bi</td><td>Calcule une valeur m de sorte que x est &eacute;gal &agrave; m fois 2 &agrave; une certaine puissance. p est un pointeur sur m.</td></tr>
<tr><td>fscanf</td><td>fscanf(s as FILE ptr, fmt as zstring ptr, ...) as integer</td><td>stdio.bi</td><td>Lit &agrave; partir d'un flux s autant d'&eacute;l&eacute;ments qu'il y a de signes % dans fmt avec des pointeurs correspondants r&eacute;pertori&eacute;s.</td></tr>
<tr><td>fseek</td><td>fseek(s as FILE ptr, offset as integer, origin as integer) as integer</td><td>stdio.bi</td><td>Localise un pointeur de fichier. Avec l'origine 0, 1 ou 2 pour le d&eacute;but, de offset octets &agrave; la fin du flux.</td></tr>
<tr><td>fsetpos</td><td>fsetpos(s as FILE ptr, p as fpos_t ptr) as integer</td><td>stdio.bi</td><td>D&eacute;finit le pointeur de fichier pour le flux s &agrave; la valeur point&eacute;e par p.</td></tr>
<tr><td>ftell</td><td>ftell(s as FILE ptr) as long</td><td>stdio.bi</td><td>Localise la position du pointeur de fichier pour le flux s</td></tr>
<tr><td>fwrite</td><td>fwrite(buf as any ptr, b as integer, c as integer, s as FILE ptr) as integer</td><td>stdio.bi</td><td>Ecrit c &eacute;l&eacute;ments de donn&eacute;es de b octets de taille &agrave; partir du tampon buf dans le fichier s. Retourne le nombre d'&eacute;l&eacute;ments de donn&eacute;es r&eacute;ellement &eacute;crits.</td></tr>
<tr><td>getc</td><td>getc(s as FILE ptr) as integer</td><td>stdio.bi</td><td>Macro pour la saisie d'un unique caract&egrave;re (ASCII) &agrave; partir du flux transmis. (stdin pour le clavier)</td></tr>
<tr><td>getchar</td><td>getchar() as integer</td><td>stdio.bi</td><td>Saisie d'un unique caract&egrave;re &agrave; partir de l'entr&eacute;e standard</td></tr>
<tr><td>gets</td><td>gets(b as zstring ptr) as zstring ptr</td><td>stdio.bi</td><td>Lit un flux de caract&egrave;res sur l'entr&eacute;e standard jusqu'&agrave; ce qu'il rencontre \n ou EOF.</td></tr>
<tr><td>hypot</td><td>hypot(x as double, y as double) as double</td><td>math.bi</td><td>Calcule l'hypot&eacute;nuse &agrave; partir des c&ocirc;t&eacute;s x et y.</td></tr>
<tr><td>isalnum</td><td>isalnum(c as integer) as integer</td><td>ctype.bi</td><td>Retourne une valeur diff&eacute;rente de z&eacute;ro si c est alphab&eacute;tique ou un chiffre.</td></tr>
<tr><td>isalpha</td><td>isalpha(c as integer) as integer</td><td>ctype.bi</td><td>Retourne une valeur diff&eacute;rente de z&eacute;ro si c est alphab&eacute;tique.</td></tr>
<tr><td>iscntrl</td><td>iscntrl(c as integer) as integer</td><td>ctype.bi</td><td>Retourne une valeur diff&eacute;rente de z&eacute;ro si c est un caract&egrave;re de contr&ocirc;le.</td></tr>
<tr><td>isdigit</td><td>isdigit(c as integer) as integer</td><td>ctype.bi</td><td>Retourne une valeur diff&eacute;rente de z&eacute;ro si c est un chiffre.</td></tr>
<tr><td>isgraph</td><td>isgraph(c as integer) as integer</td><td>ctype.bi</td><td>Retourne une valeur diff&eacute;rente de z&eacute;ro si c est alphab&eacute;tique.</td></tr>
<tr><td>islower</td><td>islower(c as integer) as integer</td><td>ctype.bi</td><td>Retourne une valeur diff&eacute;rente de z&eacute;ro si c est un caract&egrave;re minuscule.</td></tr>
<tr><td>isprint</td><td>isprint(c as integer) as integer</td><td>ctype.bi</td><td>Retourne une valeur diff&eacute;rente de z&eacute;ro si c est affichable.</td></tr>
<tr><td>ispunct</td><td>ispunct(c as integer) as integer</td><td>ctype.bi</td><td>Retourne une valeur diff&eacute;rente de z&eacute;ro si c est un caract&egrave;re de ponctuation.</td></tr>
<tr><td>isspace</td><td>isspace(c as integer) as integer</td><td>ctype.bi</td><td>Retourne une valeur diff&eacute;rente de z&eacute;ro si c est un espace.</td></tr>
<tr><td>isupper</td><td>isupper(c as integer) as integer</td><td>ctype.bi</td><td>Retourne une valeur diff&eacute;rente de z&eacute;ro si c est un caract&egrave;re majuscule.</td></tr>
<tr><td>isxdigit</td><td>isxdigit(c as integer) as integer</td><td>ctype.bi</td><td>Retourne une valeur diff&eacute;rente de z&eacute;ro si c est un chiffre hexad&eacute;cimal (0 &agrave; F ou f).</td></tr>
<tr><td>ldexp</td><td>ldexp(x as double, n as integer) as double</td><td>math.bi</td><td>Retourne le produit de x et 2 &agrave; la puissance n.</td></tr>
<tr><td>ldiv</td><td>ldiv(num as long, denom as long) as ldiv_t</td><td>stdlib.bi</td><td>Retourne le quotient et le reste d'une division sous forme de structure de type ldiv_t.</td></tr>
<tr><td>log_</td><td>log_(a as double) as double</td><td>math.bi</td><td>Retourne le logarithme naturel de l'argument.</td></tr>
<tr><td>log10</td><td>log10(a as double) as double</td><td>math.bi</td><td>Retourne le logarithme &agrave; base 10 de l'argument.</td></tr>
<tr><td>malloc</td><td>malloc(bytes as integer) as any ptr</td><td>stdlib.bi</td><td>Alloue de la m&eacute;moire. Retourne un pointeur sur un tampon permettant le stockage pour la taille sp&eacute;cifi&eacute;e.</td></tr>
<tr><td>modf</td><td>modf(d as double, p as double ptr) as double</td><td>math.bi</td><td>Retourne la partie d&eacute;cimale d'un nombre &agrave; virgule flottante d. p pointe vers la partie int&eacute;grale exprim&eacute;e comme un nombre &agrave; virgule flottante.</td></tr>
<tr><td>perror</td><td>perror(mess as zstring ptr)</td><td>stdio.bi</td><td>Affiche sur le flux stderr un message transmis comme argument.</td></tr>
<tr><td>pow</td><td>pow(x as double, y as double) as double</td><td>math.bi</td><td>Retourne x &agrave; la puissance y.</td></tr>
<tr><td>pow10</td><td>pow10(x as double) as double</td><td>math.bi</td><td>Retourne 10 &agrave; la puissance x (inverse de la fonction log10()).</td></tr>
<tr><td>printf</td><td>printf(fmt as zstring ptr, ...) as integer</td><td>stdio.bi</td><td>Affiche sur la sortie standard autant d'&eacute;l&eacute;ments que il y a de signes simples % dans fmt correspondant avec des arguments de la liste.</td></tr>
<tr><td>putc</td><td>putc(c as integer, s as FILE ptr) as integer</td><td>stdio.bi</td><td>Macro pour la sortie du caract&egrave;re unique c sur le flux s.</td></tr>
<tr><td>putchar</td><td>putchar(c as integer) as integer</td><td>stdio.bi</td><td>Macro pour la sortie du caract&egrave;re unique c sur la sortie standard.</td></tr>
<tr><td>puts</td><td>puts(b as zstring ptr) as integer</td><td>stdio.bi</td><td>Envoie le flux de caract&egrave;res dans b sur la sortie standard, renvoie 0 si l'op&eacute;ration &eacute;choue.</td></tr>
<tr><td>rand</td><td>rand() as integer</td><td>stdlib.bi</td><td>Retourne un nombre pseudo-al&eacute;atoire. Une semence est n&eacute;cessaire. Elle est fix&eacute;e avec srand.</td></tr>
<tr><td>realloc</td><td>realloc(p as any ptr, newsize as size_t) as any ptr</td><td>stdlib.bi</td><td>Alloue de la m&eacute;moire. Retourne un pointeur vers un tampon pour un changement de taille de l'objet point&eacute; par p.</td></tr>
<tr><td>rewind</td><td>rewind(s as FILE ptr)</td><td>stdio.bi</td><td>Efface les indicateurs d'erreur sur un flux fichier (lecture ou &eacute;criture). N&eacute;cessaire avant de lire un fichier modifi&eacute;.</td></tr>
<tr><td>scanf</td><td>scanf(fmt as zstring ptr,...) as integer</td><td>stdio.bi</td><td>Lit sur l'entr&eacute;e standard autant d'&eacute;l&eacute;ments qu'il y a de signes % dans fmt correspondants avec les pointeurs r&eacute;pertori&eacute;s.</td></tr>
<tr><td>sin_</td><td>sin_(ar as double) as double</td><td>math.bi</td><td>Retourne le sinus d'un angle mesur&eacute; en radians.</td></tr>
<tr><td>sinh</td><td>sinh(x as double) as double</td><td>math.bi</td><td>Retourne le sinus hyperbolique d'un angle mesur&eacute; en radians.</td></tr>
<tr><td>sprintf</td><td>sprintf(p as zstring ptr, fmt as zstring ptr, ...) as integer</td><td>stdio.bi</td><td>Affiche sur la zstring p autant d'&eacute;l&eacute;ments qu'il y a de signes % unique dans fmt correspondant aux arguments dans la liste.</td></tr>
<tr><td>sqrt</td><td>sqrt(a as double) as double</td><td>math.bi</td><td>Retourne la racine carr&eacute;e de la valeur pass&eacute;e. Erreur de domaine si la valeur est n&eacute;gative.</td></tr>
<tr><td>srand</td><td>srand(seed as uinteger)</td><td>stdlib.bi</td><td>D&eacute;finit la semence pour un nombre al&eacute;atoire. Une semence possible est l'heure courante.</td></tr>
<tr><td>sscanf</td><td>sscanf(b as zstring ptr, fmt as zstring ptr, ...) as integer</td><td>stdio.bi</td><td>Lit &agrave; partir du tampon b autant d'&eacute;l&eacute;ments qu'il y a de signes % dans fmt correspondants aux pointeurs r&eacute;pertori&eacute;s.</td></tr>
<tr><td>strcat</td><td>strcat(s1 as zstring ptr, s2 as zstring ptr) as zstring ptr</td><td>string.bi</td><td>Concat&egrave;nation (ajoute &agrave; la fin) de la zstring s2 &agrave; s1.</td></tr>
<tr><td>strchr</td><td>strchr(s as zstring ptr, c as integer) as zstring ptr</td><td>string.bi</td><td>Retourne un pointeur sur la premi&egrave;re occurrence de c dans s ou NULL si elle &eacute;choue &agrave; en trouver une.</td></tr>
<tr><td>strcmp</td><td>strcmp(s1 as zstring ptr, s2 as zstring ptr) as integer</td><td>string.bi</td><td>Compare la zstring s2 &agrave; s1. Retourne 0 ou la diff&eacute;rence sign&eacute;e dans les valeurs ASCII du premier caract&egrave;re qui ne correspond pas.</td></tr>
<tr><td>strcpy</td><td>strcpy(s1 as zstring ptr, s2 as zstring ptr) as zstring ptr</td><td>string.bi</td><td>Copie s2 dans s1.</td></tr>
<tr><td>strcspn</td><td>strcspn(s1 as zstring ptr, s2 as zstring ptr) as integer</td><td>string.bi</td><td>Retourne le nombre de caract&egrave;res rencontr&eacute;s dans s1 avant de rencontrer l'un des caract&egrave;res de s2.</td></tr>
<tr><td>strerror</td><td>strerror(n as integer) as zstring ptr</td><td>string.bi</td><td>Retourne un pointeur vers un message d'erreur syst&egrave;me correspondant au num&eacute;ro de l'erreur pass&eacute;e.</td></tr>
<tr><td>strlen</td><td>strlen(s as zstring ptr) as integer</td><td>string.bi</td><td>Retourne le nombre d'octets dans la cha&icirc;ne termin&eacute;e par "nul" (zstring) point&eacute;e par s (ne compte pas terminateur nul).</td></tr>
<tr><td>strncat</td><td>strncat(s1 as zstring ptr, s2 as zstring ptr, n as integer) as zstring ptr</td><td>string.bi</td><td>Concat&eacute;nation (ajoute &agrave; la fin) de n octets de la zstring s2 &agrave; s1.</td></tr>
<tr><td>strncmp</td><td>strncmp(s1 as zstring ptr, s2 as any ptr, n as integer) as integer</td><td>string.bi</td><td>Compare n octets de la zstring s2 aux octets correspondants de s1. Retourne 0 ou la diff&eacute;rence sign&eacute;e dans les valeurs ASCII du premier caract&egrave;re qui ne correspond pas.</td></tr>
<tr><td>strncpy</td><td>strncpy(s1 as zstring ptr, s2 as zstring ptr, n as integer) as zstring ptr</td><td>string.bi</td><td>Copie n octets de s2 dans s1.</td></tr>
<tr><td>strpbrk</td><td>strpbrk(s1 as zstring ptr, s2 as zstring ptr) as zstring ptr</td><td>string.bi</td><td>Retourne un pointeur vers le premier caract&egrave;re rencontr&eacute; dans S1 qui est aussi dans S2.</td></tr>
<tr><td>strrchr</td><td>strrchr(s as zstring ptr, c as integer) as zstring ptr</td><td>string.bi</td><td>Retourne un pointeur sur la derni&egrave;re occurrence de c dans s ou NULL si elle &eacute;choue &agrave; en trouver un.</td></tr>
<tr><td>strspn</td><td>strspn(s1 as zstring ptr, s2 as zstring ptr) as integer</td><td>string.bi</td><td>Retourne le nombre de caract&egrave;res dans s1 rencontr&eacute;s avant de rencontrer un caract&egrave;re qui n'est pas dans S2.</td></tr>
<tr><td>strstr</td><td>strstr(s1 as zstring ptr, s2 as zstring ptr) as zstring ptr</td><td>string.bi</td><td>Trouve l'emplacement de la zstring s2 dans s1 et renvoie un pointeur vers son premier caract&egrave;re.</td></tr>
<tr><td>strtod</td><td>strtod(s as zstring ptr, p as zstring ptr) as double</td><td>stdlib.bi</td><td>Convertit une zstring en double, &agrave; condition que la zstring soit &eacute;crite sous la forme d'un nombre.</td></tr>
<tr><td>strtok</td><td>strtok(s1 as zstring ptr, s2 as zstring ptr) as zstring ptr</td><td>string.bi</td><td>Retourne des pointeurs vers des symboles (tokens) successifs en utilisant la zstring s1. Les symboles consid&eacute;r&eacute;s comme des s&eacute;parateurs sont &eacute;num&eacute;r&eacute;s dans S2.</td></tr>
<tr><td>system</td><td>system(command as zstring ptr) as integer</td><td>stdlib.bi</td><td>Ex&eacute;cute, &agrave; partir d'un programme, une commande adress&eacute;e au syst&egrave;me d'exploitation &eacute;crit dans une zstring (par exemple DIR sur Windows et DOS et LS sous Linux).</td></tr>
<tr><td>tan_</td><td>tan_(ar as double) as double</td><td>math.bi</td><td>Retourne la tangente d'un angle mesur&eacute; en radians.</td></tr>
<tr><td>tanh</td><td>tanh(x as double) as double</td><td>math.bi</td><td>Retourne la tangente hyperbolique d'un angle mesur&eacute; en radians.</td></tr>
<tr><td>tolower</td><td>tolower(c as integer) as integer</td><td>ctype.bi</td><td>Convertit un caract&egrave;re majuscule en une &eacute;criture minuscule (utilise le code ASCII).</td></tr>
<tr><td>toupper</td><td>toupper(c as integer) as integer</td><td>ctype.bi</td><td>Convertit un caract&egrave;re minuscule en une &eacute;criture majnuscule (utilise le code ASCII).</td></tr>
<tr><td>ungetc</td><td>ungetc(c as integer, s as FILE ptr) as integer</td><td>stdio.bi</td><td>Envoie &agrave; nouveau un caract&egrave;re c dans le flux s, retourne EOF en cas d'&eacute;chec. Ne renoie pas plus d'un caract&egrave;re.</td></tr>
</table></div><br \>

<div class="fb_table"><table></table></div><br \>
<br \>
<a name="BUFFER"></a></div><div class="fb_sect_title">Manipulation de tampon</div><div class="fb_sect_cont"><br \>
<br \>
<tt><b>#include "crt/string.bi"</b></tt><br \>
<br \>
<div class="fb_table"><table><tr><td>Prototype (avec param&egrave;tres)</td><td>Commentaires</td></tr><tr><td>memchr(s as any ptr, c as integer, n as size_t) as any ptr</td><td>Recherche d'un caract&egrave;re dans un tampon.</td></tr><tr><td>memcmp(s1 as any ptr, s2 as any ptr, n as size_t) as integer</td><td>Comparer deux tampons.</td></tr><tr><td>memcpy(dest as any ptr, src as any ptr, n as size_t) as any ptr</td><td>Copier un tampon dans un autre.</td></tr><tr><td>memmove(dest as any ptr, src as any ptr, n as size_t) as any ptr</td><td>D&eacute;placer un certain nombre d'octets d'un tampon &agrave; un autre.</td></tr><tr><td>memset(s as any ptr, c as integer, n as size_t) as any ptr</td><td>D&eacute;finir tous les octets d'un tampon &agrave; un caract&egrave;re donn&eacute;.</td></tr></table></div><br \>
<br \>
<a name="CTYPE"></a></div><div class="fb_sect_title">Classification et conversion des caract&egrave;res</div><div class="fb_sect_cont"><br \>
<br \>
<tt><b>#include "crt/ctype.bi"</b></tt><br \>
<br \>
<div class="fb_table"><table><tr><td>Prototype (avec param&egrave;tres)</td><td>Commentaires</td></tr><tr><td>isalnum(c as integer) as integer</td><td>Vrai si c est alphanum&eacute;rique.</td></tr><tr><td>isalpha(c as integer) as integer</td><td>Vrai si c est une lettre.</td></tr><tr><td>isascii(c as integer) as integer</td><td>Vrai si  c est ASCII .</td></tr><tr><td>iscntrl(c as integer) as integer</td><td>Vrai si c est un caract&egrave;re de contr&ocirc;le.</td></tr><tr><td>isdigit(c as integer) as integer</td><td>Vrai si c est un chiffre d&eacute;cimal.</td></tr><tr><td>isgraph(c as integer) as integer</td><td>Vrai si c est un caract&egrave;re graphique.</td></tr><tr><td>islower(c as integer) as integer</td><td>Vrai si c est une lettre minuscule.</td></tr><tr><td>isprint(c as integer) as integer</td><td>Vrai si c est un caract&egrave;re imprimable.</td></tr><tr><td>ispunct(c as integer) as integer</td><td>Vrai si c est un caract&egrave;re de ponctuation.</td></tr><tr><td>isspace(c as integer) as integer</td><td>Vrai si c est un caract&egrave;re d'espace.</td></tr><tr><td>isupper(c as integer) as integer</td><td>Vrai si c est une lettre majuscule.</td></tr><tr><td>isxdigit(c as integer) as integer</td><td>Vrai si c est un chiffre hexad&eacute;cimal.</td></tr><tr><td>toascii(c as integer) as integer</td><td>Convertir c en ASCII.</td></tr><tr><td>tolower(c as integer) as integer</td><td>Convertir c en minuscules.</td></tr><tr><td>toupper(c as integer) as integer</td><td>Convertir c en majuscules.</td></tr></table></div><br \>
<br \>
<a name="DATA"></a></div><div class="fb_sect_title">Conversion de donn&eacute;es</div><div class="fb_sect_cont"><br \>
<br \>
<tt><b>#include "crt/stdlib.bi"</b></tt><br \>
<br \>
<div class="fb_table"><table><tr><td>Prototype (avec param&egrave;tres)</td><td>Commentaires</td></tr><tr><td>atof(string1 as zstring ptr) as double</td><td>Convertir zstring en valeur &agrave; virgule flottante.</td></tr><tr><td>atoi(string1 as zstring ptr) as integer</td><td>Convertir zstring en entier.</td></tr><tr><td>atol(string1 as zstring ptr) as integer</td><td>Convertir zstring en entier long.</td></tr><tr><td>itoa(value as integer, zstring as zstring ptr, radix as integer) as zstring ptr</td><td>Convertir un entier en zstring en utilisant la base (radix).</td></tr><tr><td>ltoa(value as long, zstring as zstring ptr, radix as integer) as zstring ptr</td><td>Convertir entier long en zstring dans la base (radix).</td></tr><tr><td>strtod(string1 as zstring ptr, endptr as zstring ptr) as double</td><td>Convertir zstring en valeur &agrave; virgule flottante.</td></tr><tr><td>strtol(string1 as zstring ptr, endptr as zstring ptr, radix as integer) as long</td><td>Convertir zstring en entier long en utilisant la base (radix).</td></tr><tr><td>strtoul(string1 as zstring ptr, endptr as zstring ptr, radix as integer) as ulong</td><td>Convertir zstring en long non-sign&eacute;.</td></tr></table></div><br \>
<br \>
<a name="DIRS"></a></div><div class="fb_sect_title">Manipulation de r&eacute;pertoire</div><div class="fb_sect_cont"><br \>
<br \>
<tt><b>#include "crt/io.bi"</b></tt><br \>
<br \>
<div class="fb_table"><table><tr><td>Prototype (avec param&egrave;tres)</td><td>Commentaires</td></tr><tr><td>_chdir(path as zstring ptr) as integer</td><td>Changer le r&eacute;pertoire courant vers chemin donn&eacute;.</td></tr><tr><td>_getcwd(path as zstring ptr, numchars as integer) as zstring ptr</td><td>Retourne le nom du r&eacute;pertoire de travail courant.</td></tr><tr><td>_mkdir(path as zstring ptr) as integer</td><td>Cr&eacute;er un r&eacute;pertoire en utilisant le nom de chemin d'acc&egrave;s donn&eacute;.</td></tr><tr><td>_rmdir(path as zstring ptr) as integer</td><td>Supprimer un r&eacute;pertoire sp&eacute;cifi&eacute;.</td></tr></table></div><br \>
<br \>
<a name="FILES"></a></div><div class="fb_sect_title">Manipulation de fichiers</div><div class="fb_sect_cont"><br \>
<br \>
<tt><b>#include "crt/sys/stat.bi"</b></tt><br \>
<tt><b>#include "crt/io.bi"</b></tt><br \>
<br \>
<div class="fb_table"><table><tr><td>Prototype (avec param&egrave;tres)</td><td>Commentaires</td></tr><tr><td>chmod(path as zstring ptr, pmode as integer) as integer</td><td>Modifie les param&egrave;tres de permissions d'un fichier.</td></tr><tr><td>fstat(handle as integer, buffer as type stat ptr) as integer</td><td>Obtient des informations d'&eacute;tat du fichier.</td></tr><tr><td>remove(path as zstring ptr) as integer</td><td>Supprimer un fichier nomm&eacute;.</td></tr><tr><td>rename_(oldname as zstring ptr, newname as zstring ptr) as integer</td><td>Renommer un fichier.</td></tr><tr><td>stat(path as zstring ptr, buffer as type stat ptr) as integer</td><td>Obtenir des informations d'&eacute;tat du fichier nomm&eacute;.</td></tr><tr><td>umask(pmode as uinteger) as uinteger</td><td>D&eacute;finir le masque de permissions du fichier.</td></tr></table></div><br \>
<br \>
<a name="STREAM"></a></div><div class="fb_sect_title">Flux E/S</div><div class="fb_sect_cont"><br \>
<br \>
<tt><b>#include "crt/stdio.bi"</b></tt><br \>
<br \>
<div class="fb_table"><table><tr><td>Prototype (avec param&egrave;tres)</td><td>Commentaires</td></tr><tr><td>clearerr(file_pointer as FILE ptr)</td><td>Efface l'indicateur d'erreur de flux,</td></tr><tr><td>fclose(file_pointer as FILE ptr) as integer</td><td>Fermer un fichier.</td></tr><tr><td>feof(file_pointer as FILE ptr) as integer</td><td>Check if end of file occurred on a stream.</td></tr><tr><td>ferror(file_pointer as FILE ptr) as integer</td><td>V&eacute;rifier si une erreur s'est produite lors d'une E/S fichier.</td></tr><tr><td>fflush(file_pointer as FILE ptr) as integer</td><td>&Eacute;crire (vider) un tampon vers le fichier.</td></tr><tr><td>fgetc(file_pointer as FILE ptr) as integer</td><td>Obtenir un caract&egrave;re &agrave; partir d'un flux.</td></tr><tr><td>fgetpos(file_pointer as FILE ptr, fpos_t current_pos) as integer</td><td>Obtenir la position courante dans un flux.</td></tr><tr><td>fgets(string1 as zstring ptr, maxchar as integer, file_pointer as FILE ptr) as zstring ptr</td><td>Lire une zstring &agrave; partir d'un fichier.</td></tr><tr><td>fopen(filename as zstring ptr, access_mode as zstring ptr) as FILE ptr</td><td>Ouvrir un fichier pour tampon E/S.</td></tr><tr><td>fprintf(file_pointer as FILE ptr, format_string as zstring ptr, args) as integer</td><td>&Eacute;crire la sortie format&eacute;e dans un fichier.</td></tr><tr><td>fputc(c as integer, file_pointer as FILE ptr) as integer</td><td>&Eacute;crire un caract&egrave;re vers un flux.</td></tr><tr><td>fputchar(c as integer) as integer</td><td>&Eacute;crire un caract&egrave;re vers stdout.</td></tr><tr><td>fputs(string1 as zstring ptr, file_pointer as FILE ptr) as integer</td><td>Ecrire une zstring vers un flux.</td></tr><tr><td>fread(buffer as zstring ptr, size as size_t count as size_t, file_pointer as FILE ptr) as size_t</td><td>Lire des donn&eacute;es non format&eacute;es d'un flux dans un un tampon.</td></tr><tr><td>freopen(filename as zstring ptr, access as zstring ptr mode, file_pointer as FILE ptr) as FILE ptr</td><td>R&eacute;affecter un pointeur fichier vers un autre fichier.</td></tr><tr><td>fscanf(file_pointer as FILE ptr, format as zstring ptr zstring, args) as integer</td><td>Lire une entr&eacute;e format&eacute;e &agrave; partir d'un flux.</td></tr><tr><td>fseek(file_pointer as FILE ptr, offset as long, origin as integer) as integer</td><td>D&eacute;finir la position courante dans fichier vers un nouvel emplacement.</td></tr><tr><td>fsetpos(file_pointer as FILE ptr, current_pos as fpos_t) as integer</td><td>D&eacute;finir la position courante dans le fichier vers un nouvel emplacement.</td></tr><tr><td>ftell(file_pointer as FILE ptr) as long</td><td>Obtenir l'emplacement courant dans le dossier.</td></tr><tr><td>fwrite(buffer as zstring ptr, size as size_t, count as size_t file_pointer as FILE ptr) as size_t</td><td>&Eacute;crire des donn&eacute;es non format&eacute;es &agrave; partir d'un tampon vers un flux.</td></tr><tr><td>getc(file_pointer as FILE ptr) as integer</td><td>Lire un caract&egrave;re &agrave; partir d'un flux.</td></tr><tr><td>getchar() as integer</td><td>Lire un caract&egrave;re &agrave; partir de stdin.</td></tr><tr><td>gets(buffer as zstring ptr) as zstring ptr</td><td>Lire une ligne depuis stdin vers un tampon.</td></tr><tr><td>printf(format as zstring ptr _string, args) as integer</td><td>&Eacute;crire une sortie format&eacute;e vers stdout.</td></tr><tr><td>putc(c as integer, file_pointer as FILE ptr) as integer</td><td>&Eacute;crire un caract&egrave;re vers un flux.</td></tr><tr><td>putchar(c as integer) as integer</td><td>&Eacute;crire un caract&egrave;re vers stdout.</td></tr><tr><td>puts(string1 as zstring ptr) as integer</td><td>Ecrire une zstring vers stdout.</td></tr><tr><td>rewind(file_pointer as FILE ptr)</td><td>Rembobiner un fichier.</td></tr><tr><td>scanf(format_string as zstring ptr, args) as integer</td><td>Lire une entr&eacute;e format&eacute;e de stdin.</td></tr><tr><td>setbuf(file_pointer as FILE ptr, buffer as zstring ptr)</td><td>Mettre en place un nouveau tampon pour le flux.</td></tr><tr><td>setvbuf(file_pointer as FILE ptr, buffer as zstring ptr, buf_type as integer, buf as size_t size) as integer</td><td>Mettre en place un nouveau tampon et contr&ocirc;ler le niveau de mise en m&eacute;moire tampon sur un flux.</td></tr><tr><td>sprintf(string1 as zstring ptr, format_string as zstring ptr, args) as integer</td><td>&Eacute;crire une sortie format&eacute;e vers une zstring.</td></tr><tr><td>sscanf(buffer as zstring ptr, format_string as zstring ptr, args) as integer</td><td>Lire une zstring &agrave; partir d'une entr&eacute;e format&eacute;e.</td></tr><tr><td>tmpfile() as FILE ptr</td><td>Ouvrir un fichier temporaire.</td></tr><tr><td>tmpnam(file_name as zstring ptr) as zstring ptr</td><td>Obtenir le nom d'un fichier temporaire.</td></tr><tr><td>ungetc(c as integer, file_pointer as FILE ptr) as integer</td><td>Repousser un caract&egrave;re dans un tampon de flux</td></tr></table></div><br \>
<br \>
<a name="LOLEVIO"></a></div><div class="fb_sect_title">E/S bas niveau</div><div class="fb_sect_cont"><br \>
<br \>
<tt><b>#include "crt/io.bi"</b></tt><br \>
<br \>
Jusqu'&agrave; pr&eacute;sent, Win32 seulement, se connecte &agrave; MSVCRT.DLL (en-t&ecirc;tes manquantes pour d'autres plates-formes)<br \>
<br \>
<div class="fb_table"><table><tr><td>Prototype (avec param&egrave;tres)</td><td>Commentaires</td></tr><tr><td>_close(handle as integer) as integer</td><td>Fermer un fichier ouvert pour E/S non-tamponn&eacute;e.</td></tr><tr><td>_creat(filename as zstring ptr, pmode as integer) as integer</td><td>Cr&eacute;er un nouveau fichier avec la permission sp&eacute;cifi&eacute;e.</td></tr><tr><td>_eof(handle as integer) as integer</td><td>V&eacute;rifier la fin du fichier.</td></tr><tr><td>_lseek(handle as integer, offset as long, origin as integer) as long</td><td>Aller &agrave; une position sp&eacute;cifique dans un fichier.</td></tr><tr><td>_open(filename as zstring ptr, oflag as integer, pmode as uinteger) as integer</td><td>Ouvrir un fichier &agrave; faible niveau E/S.</td></tr><tr><td>_read(handle as integer, buffer as zstring ptr, length as uinteger) as integer</td><td>Lire des donn&eacute;es binaires &agrave; partir d'un fichier dans un tampon.</td></tr><tr><td>_write(handle as integer, buffer as zstring ptr, count as uinteger) as integer</td><td>&Eacute;crire des donn&eacute;es binaires &agrave; partir d'un tampon dans un fichier.</td></tr></table></div><br \>
<br \>
<a name="MATH"></a></div><div class="fb_sect_title">Math&eacute;matiques</div><div class="fb_sect_cont"><br \>
<br \>
<tt><b>#include "crt/math.bi"</b></tt><br \>
<br \>
<div class="fb_table"><table><tr><td>Prototype (avec param&egrave;tres)</td><td>Commentaires</td></tr><tr><td>abs_(n as integer) as integer</td><td>R&eacute;cup&egrave;re la valeur absolue d'un entier.</td></tr><tr><td>acos_(x as double) as double</td><td>Calcule arc cosinus de x.</td></tr><tr><td>asin_(x as double) as double</td><td>Calcule arc sinus de x.</td></tr><tr><td>atan_(x as double) as double</td><td>Calcule arc tangente de x.</td></tr><tr><td>atan2_(y as double, x as double) as double</td><td>Calcule arc tangente de y/x.</td></tr><tr><td>ceil(x as double) as double</td><td>Obtient plus petite valeur enti&egrave;re qui d&eacute;passe x.</td></tr><tr><td>cos_(x as double) as double</td><td>Calcule cosinus de l'angle en radians.</td></tr><tr><td>cosh(x as double) as double</td><td>Calcule le cosinus hyperbolique de x.</td></tr><tr><td>div(number as integer, denom as integer) as div_t</td><td>Diviser un entier par un autre.</td></tr><tr><td>exp_(x as double) as double</td><td>Calcule exponentielle de x.</td></tr><tr><td>fabs(x as double) as double</td><td>Calcule la valeur absolue de x.</td></tr><tr><td>floor(x as double) as double</td><td>Obtient plus grande valeur enti&egrave;re inf&eacute;rieure &agrave; x.</td></tr><tr><td>fmod(x as double, y as double) as double</td><td>Diviser x par y avec un quotient entier et retourne le reste.</td></tr><tr><td>frexp(x as double, expptr as integer ptr) as double</td><td>D&eacute;compose x en mantisse et exposant.</td></tr><tr><td>labs(n as long) as long</td><td>Trouver valeur absolue d'un nombre entier long n.</td></tr><tr><td>ldexp(x as double, exp as integer) as double</td><td>Reconstruit x &agrave; partir de la mantisse et d'un exposant de deux.</td></tr><tr><td>ldiv(number as long, denom as long) as ldiv_t</td><td>Diviser un entier long par un autre.</td></tr><tr><td>log_(x as double) as double</td><td>Calcule log(x).</td></tr><tr><td>log10(x as double) as double</td><td>Calcule log base 10 de x.</td></tr><tr><td>modf(x as double, intptr as double ptr) as double</td><td>D&eacute;compose x en partie enti&egrave;re et partie d&eacute;cimale.</td></tr><tr><td>pow(x as double, y as double) as double</td><td>Calcule x &eacute;lev&eacute; &agrave; la puissance y.</td></tr><tr><td>rand() as integer</td><td>Obtient un entier al&eacute;atoire compris entre 0 et 32.</td></tr><tr><td>random(max_num as integer) as integer</td><td>Obtenir un entier al&eacute;atoire compris entre 0 et max_num.</td></tr><tr><td>randomize()</td><td>D&eacute;finir une "graine" al&eacute;atoire pour le g&eacute;n&eacute;rateur de nombres al&eacute;atoires.</td></tr><tr><td>sin_(x as double) as double</td><td>Calcule le sinus de l'angle en radians.</td></tr><tr><td>sinh(x as double) as double</td><td>Calcule le sinus hyperbolique de x.</td></tr><tr><td>sqrt(x as double) as double</td><td>Calcule la racine carr&eacute;e de x.</td></tr><tr><td>srand(seed as uinteger)</td><td>D&eacute;finir une nouvelle graine pour le g&eacute;n&eacute;rateur de nombre al&eacute;atoire (rand).</td></tr><tr><td>tan_(x as double) as double</td><td>Calcule la tangente de l'angle en radians.</td></tr><tr><td>tanh(x as double) as double</td><td>Calcule la tangente hyperbolique de x.</td></tr></table></div><br \>
<br \>
<a name="MEMORY"></a></div><div class="fb_sect_title">Allocation m&eacute;moire</div><div class="fb_sect_cont"><br \>
<br \>
<tt><b>#include "crt/stdlib.bi"</b></tt><br \>
<br \>
<div class="fb_table"><table><tr><td>Prototype (avec param&egrave;tres)</td><td>Commentaires</td></tr><tr><td>calloc(num as size_t elems, elem_size as size_t) as any ptr</td><td>Allouer un tableau et initialiser tous ses &eacute;l&eacute;ments &agrave; z&eacute;ro.</td></tr><tr><td>free(mem_address as any ptr)</td><td>Lib&eacute;rer un bloc de m&eacute;moire.</td></tr><tr><td>malloc(num as size_t bytes) as any ptr</td><td>Allouer un bloc de m&eacute;moire.</td></tr><tr><td>realloc(mem_address as any ptr, newsize as size_t) as any ptr</td><td>R&eacute;affecter (ajuster la taille) un bloc de m&eacute;moire.</td></tr></table></div><br \>
<br \>
<a name="PROCESS"></a></div><div class="fb_sect_title">Contr&ocirc;le de processus</div><div class="fb_sect_cont"><br \>
<br \>
<tt><b>#include "crt/stdlib.bi"</b></tt><br \>
<br \>
<div class="fb_table"><table><tr><td>Prototype (avec param&egrave;tres)</td><td>Commentaires</td></tr><tr><td>abort()</td><td>Abandonner un processus.</td></tr><tr><td>execl(path as zstring ptr, arg0 as zstring ptr, arg1 as zstring ptr,..., NULL) as integer</td><td>Lancer un processus fils (passe la ligne de commande).</td></tr><tr><td>execlp(path as zstring ptr, arg0 as zstring ptr, arg1 as zstring ptr,..., NULL) as integer</td><td>Lancer enfant (utilisation de PATH, passer la ligne de commande).</td></tr><tr><td>execv(path as zstring ptr, argv as zstring ptr) as integer</td><td>Lancer enfant (passe vecteur argument).</td></tr><tr><td>execvp(path as zstring ptr, argv as zstring ptr) as integer</td><td>Lancement enfant (utiliser PATH, passer vecteur d'argument).</td></tr><tr><td>exit_(status as integer)</td><td>Terminer un processus apr&egrave;s nettoyage de tous les tampons.</td></tr><tr><td>getenv(varname as zstring ptr) as zstring ptr</td><td>R&eacute;cup&egrave;re la d&eacute;finition de la variable d'environnement,</td></tr><tr><td>perror(string1 as zstring ptr)</td><td>Affiche un message d'erreur correspondant &agrave; la derni&egrave;re erreur syst&egrave;me.</td></tr><tr><td>putenv(envstring as zstring ptr) as integer</td><td>Ins&eacute;rer une nouvelle d&eacute;finition dans la table d' environnement.</td></tr><tr><td>raise(signum as integer) as integer</td><td>G&eacute;n&eacute;rer un signal C (exception).</td></tr><tr><td>system_(string1 as zstring ptr) as integer</td><td> Ex&eacute;cuter une commande du syst&egrave;me d'exploitation r&eacute;sident.</td></tr></table></div><br \>
<br \>
<a name="SORTING"></a></div><div class="fb_sect_title">Recherche et Tri</div><div class="fb_sect_cont"><br \>
<br \>
<tt><b>#include "crt/stdlib.bi"</b></tt><br \>
<div class="fb_indent"><div class="fb_indent">    <b>Note:</b> La fonction de rappel <i>compare</i> requise par <tt><i>bsearch</i></tt> et <tt><i>qsort</i></tt> doit &ecirc;tre d&eacute;clar&eacute;e comme <tt><a href="KeyPgCdecl.html">cdecl</a></tt>. Elle doit retourner une valeur &lt;0 si son premier argument doit &ecirc;tre situ&eacute; avant le second dans le tableau tri&eacute;, &gt;0 si le premier argument doit &ecirc;tre plac&eacute; apr&egrave;s le deuxi&egrave;me, et &agrave; z&eacute;ro si leurs positions relatives sont indiff&eacute;rents (valeurs &eacute;gales).  <br \>
<br \>
</div></div><div class="fb_table"><table><tr><td>Prototype (avec param&egrave;tres)</td><td>Commentaires</td></tr><tr><td>bsearch(key as any ptr, base as any ptr, num as size_t, width as size_t, compare as function(elem1 as any ptr, elem2 as any ptr) as integer) as any ptr</td><td>Effectuer une recherche binaire.</td></tr><tr><td>qsort(base as any ptr, num as size_t, width as size_t, compare as function(elem1 as any ptr, elem2 as any ptr) as integer)</td><td>Utilisez l'algorithme de tri rapide pour trier un tableau.</td></tr></table></div><br \>
<br \>
<a name="STRING"></a></div><div class="fb_sect_title">Manipulation de cha&icirc;nes</div><div class="fb_sect_cont"><br \>
<br \>
<tt><b>#include "crt/string.bi"</b></tt><br \>
<br \>
<div class="fb_table"><table><tr><td>Prototype (avec param&egrave;tres)</td><td>Commentaires</td></tr><tr><td>stpcpy(dest as zstring ptr, src as zstring ptr) as zstring ptr</td><td>Copier une zstring dans une autre.</td></tr><tr><td>strcmp(string1 as zstring ptr, string2 as zstring ptr) as integer</td><td>Comparer string1 et string2 pour d&eacute;terminer l'ordre alphab&eacute;tique.</td></tr><tr><td>strcpy(string1 as zstring ptr, string2 as zstring ptr) as zstring ptr</td><td>Copier string2 vers string1.</td></tr><tr><td>strerror(errnum as integer) as zstring ptr</td><td>Obtenir le message d'erreur correspondant au num&eacute;ro d'erreur sp&eacute;cifi&eacute;.</td></tr><tr><td>strlen(string1 as zstring ptr) as integer</td><td>D&eacute;terminer la longueur d'une zstring.</td></tr><tr><td>strncat(string1 as zstring ptr, string2 as zstring ptr, n as size_t) as zstring ptr</td><td>Ajoute (Append) n caract&egrave;res de string2 vers string1.</td></tr><tr><td>strncmp(string1 as zstring ptr, string2 as zstring ptr, n as size_t) as integer</td><td>Comparer les n premiers caract&egrave;res de deux cha&icirc;nes.</td></tr><tr><td>strncpy(string1 as zstring ptr, string2 as zstring ptr, n as size_t) as zstring ptr</td><td>Copier les n premiers caract&egrave;res de string2 vers string1.</td></tr><tr><td>strnset(string1 as zstring ptr, c as integer, size _t n) as zstring ptr</td><td>Mettre les n premiers caract&egrave;res de zstring &agrave; c.</td></tr><tr><td>strrchr(string1 as zstring ptr, c as integer) as zstring ptr</td><td>Trouver la derni&egrave;re occurrence du caract&egrave;re c dans zstring.</td></tr></table></div><br \>
<br \>
<a name="TIME"></a></div><div class="fb_sect_title">Temps</div><div class="fb_sect_cont"><br \>
<br \>
<tt><b>#include "crt/time.bi"</b></tt><br \>
<br \>
<div class="fb_table"><table><tr><td>Prototype (avec param&egrave;tres)</td><td>Commentaires</td></tr><tr><td>asctime(time as type tm ptr) as zstring ptr</td><td>Convertir le temps de type tm en zstring.</td></tr><tr><td>clock() as clock_t</td><td>Obtenir le temps processeur &eacute;coul&eacute; en tops d'horloge.</td></tr><tr><td>ctime(time as time_t ptr) as zstring ptr</td><td>Convertir le temps binaire en zstring.</td></tr><tr><td>difftime(time_t time2, time_t time1) as double</td><td>Calculer la diff&eacute;rence entre deux temps en secondes.</td></tr><tr><td>gmtime(time as time_t ptr) as type tm ptr</td><td>Obtenir Greenwich Mean Time (GMT) dans une structure tm.</td></tr><tr><td>localtime(time as time_t ptr) as type tm ptr</td><td>Obtenir l'heure locale dans une structure tm.</td></tr><tr><td>time_(timeptr as time_t ptr) as time_t</td><td>Retourne l'heure actuelle en secondes &eacute;coul&eacute;es depuis 0 heures GMT 1/1/70.</td></tr></table></div><br \>
<br \>
</div><div class="fb_sect_title">Voir aussi</div><div class="fb_sect_cont"><br \>
<ul><li> <tt><a href="KeyPgInclude.html">#include</a></tt><br \>
<br \>
</ul><br \>
   <br \>
</div>
</div>
</div> 
</div> 
</body>
</html>
