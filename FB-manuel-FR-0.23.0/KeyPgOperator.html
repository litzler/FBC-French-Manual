<html>
<head>
<title>Operator</title>
<link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
<div id="fb_body_wrapper">
<div id="fb_tab">
<div id="fb_tab_l">Operator</div>
<div id="fb_tab_r">&nbsp;<img src="images/fblogo_mini.gif" /></div> 
</div> 
<div id="fb_pg_wrapper">
<div id="fb_pg_body">
	D&eacute;clare ou d&eacute;finit un op&eacute;rateur surcharg&eacute;.<br \>
<br \>
<div class="fb_sect_title">Syntaxe</div><div class="fb_sect_cont"><tt><br \>
{ <a href="KeyPgType.html">Type</a> | <a href="KeyPgClass.html">Class</a> | <a href="KeyPgUnion.html">Union</a> | <a href="KeyPgEnum.html">Enum</a> } <i>typename</i><br \>
<div class="fb_indent"><a href="KeyPgDeclare.html">Declare</a> <b>Operator</b> <a href="KeyPgCast.html">Cast</a> () <a href="KeyPgAs.html">As</a> <a href="DataType.html">datatype</a><br \>
<a href="KeyPgDeclare.html">Declare</a> <b>Operator</b> <i>assignment_op</i> ( [ <a href="KeyPgByref.html">ByRef</a> | <a href="KeyPgByval.html">ByVal</a> ] <i>rhs</i> <a href="KeyPgAs.html">As</a> <a href="DataType.html">datatype</a> )<br \>
<a href="KeyPgDeclare.html">Declare</a> <b>Operator</b> <a href="KeyPgOpNew.html">New</a> ( <i>size</i> <a href="KeyPgAs.html">As</a> <a href="KeyPgUinteger.html">UInteger</a> ) <a href="KeyPgAs.html">As</a> <a href="KeyPgAny.html">Any</a> <a href="KeyPgPtr.html">Ptr</a><br \>
<a href="KeyPgDeclare.html">Declare</a> <a href="KeyPgStaticMember.html">Static</a> <b>Operator</b> <a href="KeyPgOpNew.html">New</a>[] ( <i>size</i> <a href="KeyPgAs.html">As</a> <a href="KeyPgUinteger.html">UInteger</a> ) <a href="KeyPgAs.html">As</a> <a href="KeyPgAny.html">Any</a> <a href="KeyPgPtr.html">Ptr</a><br \>
<a href="KeyPgDeclare.html">Declare</a> <b>Operator</b> <a href="KeyPgOpDelete.html">Delete</a> ( <i>buf</i>  <a href="KeyPgAs.html">As</a> <a href="KeyPgAny.html">Any</a> <a href="KeyPgPtr.html">Ptr</a> )<br \>
<a href="KeyPgDeclare.html">Declare</a> <a href="KeyPgStaticMember.html">Static</a> <b>Operator</b> <a href="KeyPgOpDelete.html">Delete</a>[] ( <i>buf</i>  <a href="KeyPgAs.html">As</a> <a href="KeyPgAny.html">Any</a> <a href="KeyPgPtr.html">Ptr</a> )<br \>
</div>End { <a href="KeyPgType.html">Type</a> | <a href="KeyPgClass.html">Class</a> | <a href="KeyPgUnion.html">Union</a> | <a href="KeyPgEnum.html">Enum</a> }<br \>
<br \>
{ <a href="KeyPgType.html">Type</a> | <a href="KeyPgClass.html">Class</a> | <a href="KeyPgUnion.html">Union</a> } <i>typename</i><br \>
<div class="fb_indent"><a href="KeyPgDeclare.html">Declare</a> <b>Operator</b> <a href="KeyPgOpFor.html">For</a> ()<br \>
<a href="KeyPgDeclare.html">Declare</a> <b>Operator</b> <a href="KeyPgOpFor.html">For</a> ( [ <a href="KeyPgByref.html">ByRef</a> | <a href="KeyPgByval.html">ByVal</a> ] <i>stp</i> <a href="KeyPgAs.html">As</a> <i>typename</i> )<br \>
<a href="KeyPgDeclare.html">Declare</a> <b>Operator</b> <a href="KeyPgOpStep.html">Step</a> ()<br \>
<a href="KeyPgDeclare.html">Declare</a> <b>Operator</b> <a href="KeyPgOpStep.html">Step</a> ( [ <a href="KeyPgByref.html">ByRef</a> | <a href="KeyPgByval.html">ByVal</a> ] <i>stp</i> <a href="KeyPgAs.html">As</a> <i>typename</i> )<br \>
<a href="KeyPgDeclare.html">Declare</a> <b>Operator</b> <a href="KeyPgOpNext.html">Next</a> ( [ <a href="KeyPgByref.html">ByRef</a> | <a href="KeyPgByval.html">ByVal</a> ] <i>cond</i> <a href="KeyPgAs.html">As</a> <i>typename</i> ) <a href="KeyPgAs.html">As</a> <a href="KeyPgInteger.html">Integer</a><br \>
<a href="KeyPgDeclare.html">Declare</a> <b>Operator</b> <a href="KeyPgOpNext.html">Next</a> ( [ <a href="KeyPgByref.html">ByRef</a> | <a href="KeyPgByval.html">ByVal</a> ] <i>cond</i> <a href="KeyPgAs.html">As</a> <i>typename</i>, [ <a href="KeyPgByref.html">ByRef</a> | <a href="KeyPgByval.html">ByVal</a> ] <i>stp</i> <a href="KeyPgAs.html">As</a> <i>typename</i> ) <a href="KeyPgAs.html">As</a> <a href="KeyPgInteger.html">Integer</a><br \>
</div>End { <a href="KeyPgType.html">Type</a> | <a href="KeyPgClass.html">Class</a> | <a href="KeyPgUnion.html">Union</a> }<br \>
<br \>
<a href="KeyPgDeclare.html">Declare</a> <b>Operator</b> <i>unary_op</i> ( [ <a href="KeyPgByref.html">ByRef</a> | <a href="KeyPgByval.html">ByVal</a> ] <i>rhs</i> <a href="KeyPgAs.html">As</a> <a href="DataType.html">datatype</a> ) <a href="KeyPgAs.html">As</a> <a href="DataType.html">datatype</a><br \>
<a href="KeyPgDeclare.html">Declare</a> <b>Operator</b> <i>binary_op</i> ( [ <a href="KeyPgByref.html">ByRef</a> | <a href="KeyPgByval.html">ByVal</a> ] <i>lhs</i> <a href="KeyPgAs.html">As</a> <a href="DataType.html">datatype</a>, [ <a href="KeyPgByref.html">ByRef</a> | <a href="KeyPgByval.html">ByVal</a> ] <i>rhs</i> <a href="KeyPgAs.html">As</a> <a href="DataType.html">datatype</a> ) <a href="KeyPgAs.html">As</a> <a href="DataType.html">datatype</a><br \>
<br \>
<b>Operator</b> <i>typename</i>.<a href="KeyPgCast.html">Cast</a> () <a href="KeyPgAs.html">As</a> <a href="DataType.html">datatype</a><br \>
<b>Operator</b> <i>typename</i>.<i>assignment_op</i> ( [ <a href="KeyPgByref.html">ByRef</a> | <a href="KeyPgByval.html">ByVal</a> ] <i>rhs</i> <a href="KeyPgAs.html">As</a> <a href="DataType.html">datatype</a> )<br \>
<b>Operator</b> <i>unary_op</i> ( [ <a href="KeyPgByref.html">ByRef</a> | <a href="KeyPgByval.html">ByVal</a> ] <i>rhs</i> <a href="KeyPgAs.html">As</a> <a href="DataType.html">datatype</a> ) <a href="KeyPgAs.html">As</a> <a href="DataType.html">datatype</a><br \>
<b>Operator</b> <i>binary_op</i> ( [ <a href="KeyPgByref.html">ByRef</a> | <a href="KeyPgByval.html">ByVal</a> ] <i>lhs</i> <a href="KeyPgAs.html">As</a> <a href="DataType.html">datatype</a>, [ <a href="KeyPgByref.html">ByRef</a> | <a href="KeyPgByval.html">ByVal</a> ] <i>rhs</i> <a href="KeyPgAs.html">As</a> <a href="DataType.html">datatype</a> ) <a href="KeyPgAs.html">As</a> <a href="DataType.html">datatype</a><br \>
<b>Operator</b> <i>typename</i>.<a href="KeyPgOpNew.html">New</a> ( <i>size</i> as uinteger ) <a href="KeyPgAs.html">As</a> <a href="KeyPgAny.html">Any</a> <a href="KeyPgPtr.html">Ptr</a><br \>
<a href="KeyPgStaticMember.html">Static</a> <b>Operator</b> <i>typename</i>.<a href="KeyPgOpNew.html">New</a>[] ( <i>size</i> <a href="KeyPgAs.html">As</a> <a href="KeyPgUinteger.html">UInteger</a> ) <a href="KeyPgAs.html">As</a> <a href="KeyPgAny.html">Any</a> <a href="KeyPgPtr.html">Ptr</a><br \>
<b>Operator</b> <i>typename</i>.<a href="KeyPgOpDelete.html">Delete</a> ( <i>buf</i>  <a href="KeyPgAs.html">As</a> <a href="KeyPgAny.html">Any</a> <a href="KeyPgPtr.html">Ptr</a> )<br \>
<a href="KeyPgStaticMember.html">Static</a> <b>Operator</b> <i>typename</i>.<a href="KeyPgOpDelete.html">Delete</a>[] ( <i>buf</i>  <a href="KeyPgAs.html">As</a> <a href="KeyPgAny.html">Any</a> <a href="KeyPgPtr.html">Ptr</a> )<br \>
</tt><br \>
</div><div class="fb_sect_title">Param&egrave;tres</div><div class="fb_sect_cont"><br \>
<tt><i>typename</i></tt> <br \>
<div class="fb_indent">Nom de <tt><a href="KeyPgType.html">Type</a></tt>, <tt><a href="KeyPgClass.html">Class</a></tt>, <tt><a href="KeyPgUnion.html">Union</a></tt> ou <tt><a href="KeyPgEnum.html">Enum</a></tt>.<br \>
</div><tt><i>assignment_op</i></tt> <br \>
<div class="fb_indent"><tt>let += -= *= /= \= mod= shl= shr= and= or= xor= imp= eqv= ^=</tt><br \>
</div><tt><i>unary_op</i></tt><br \>
<div class="fb_indent"><tt>- not @ * -&gt; abs sgn fix frac int exp log sin asin cos acos tan atn</tt><br \>
</div><tt><i>binary_op</i></tt><br \>
<div class="fb_indent"><tt>+ - * / \ mod shl shr and or xor imp eqv ^ = &lt;&gt; &lt; &gt; &lt;= &gt;= andalso orelse</tt><br \>
<br \>
</div></div><div class="fb_sect_title">Description</div><div class="fb_sect_cont"><br \>
Les op&eacute;rateurs int&eacute;gr&eacute;s comme <tt>=</tt>, <tt>+</tt> et <tt>cast</tt> ont des comportements pr&eacute;d&eacute;finis lorsqu'ils sont utilis&eacute;s dans des expressions.  Ces op&eacute;rateurs peuvent &ecirc;tre surcharg&eacute;s pour faire autre chose que ces op&eacute;rations pr&eacute;d&eacute;finies lorsqu'au moins l'un des arguments de l'op&eacute;rateur est un type de donn&eacute;es <tt><a href="KeyPgType.html">Type</a></tt>, <tt><a href="KeyPgClass.html">Class</a></tt>, <tt><a href="KeyPgEnum.html">Enum</a></tt> ou <tt><a href="KeyPgUnion.html">Union</a></tt>.<br \>
<br \>
Les op&eacute;rateurs sont juste des fonctions.  L'op&eacute;rateur '+' a les fonctionnalit&eacute;s de la fonction <tt>Function Plus( A as DataType, B as DataType ) as DataType</tt>.  Voir <i><a href="ProPgOperatorOverloading.html">Surcharge d'op&eacute;rateur</a></i> pour plus d'informations.  Les op&eacute;rateurs peuvent &ecirc;tre surcharg&eacute;s  pour accepter diff&eacute;rents types de donn&eacute;es en tant que param&egrave;tres.  Seul l'op&eacute;rateur <tt><a href="KeyPgCast.html">Cast</a></tt> peut &ecirc;tre surcharg&eacute; pour retourner diff&eacute;rents types.<br \>
<br \>
Les membres op&eacute;rateur non-statiques sont d&eacute;clar&eacute;s &agrave; l'int&eacute;rieur de <tt><a href="KeyPgType.html">Type</a></tt> ou <tt><a href="KeyPgClass.html">Class</a></tt>.  Les op&eacute;rateurs globaux sont d&eacute;clar&eacute;s en dehors.  Toutes les d&eacute;finitions de l'op&eacute;rateur (corps de proc&eacute;dure) doivent appara&icirc;tre en dehors.<br \>
<br \>
<tt><b>Let</b></tt>, <tt><b>Cast</b></tt> et autres op&eacute;rateurs d'affectation doivent &ecirc;tre d&eacute;clar&eacute;s &agrave; l'int&eacute;rieur de <tt><a href="KeyPgType.html">Type</a></tt> ou <tt><a href="KeyPgClass.html">Class</a></tt>.  Ils transmettent un param&egrave;tre cach&eacute; <tt><a href="KeyPgThis.html">This</a></tt> et ont une valeur de retour du m&ecirc;me type de donn&eacute;es que le <tt><a href="KeyPgType.html">Type</a></tt> ou la <tt><a href="KeyPgClass.html">Class</a></tt> o&ugrave; ils ont &eacute;t&eacute; d&eacute;clar&eacute;s.<br \>
<br \>
Les op&eacute;rateurs unaires doit &ecirc;tre d&eacute;clar&eacute;s en dehors de <tt><a href="KeyPgType.html">Type</a></tt>, <tt><a href="KeyPgClass.html">Class</a></tt> ou <tt><a href="KeyPgEnum.html">Enum</a></tt> et ont un type de donn&eacute;es de retour d&eacute;clar&eacute; explicitement.  Les op&eacute;rateurs unaires peuvent &ecirc;tre surcharg&eacute;s pour retourner tout type valide de donn&eacute;es, sauf pour <tt><a href="KeyPgOpPtrMemberAccess.html">Operator -&gt; (Pointeur vers Acc&egrave;s membre)</a></tt> qui doit retourner un type de donn&eacute;es <tt><a href="KeyPgType.html">Type</a></tt> ou <tt><a href="KeyPgClass.html">Class</a></tt>.<br \>
<br \>
Les op&eacute;rateurs binaires doivent &ecirc;tre d&eacute;clar&eacute;s en dehors de <tt><a href="KeyPgType.html">Type</a></tt>, <tt><a href="KeyPgClass.html">Class</a></tt> ou <tt><a href="KeyPgEnum.html">Enum</a></tt> et ont un type de donn&eacute;es de retour explicitement d&eacute;clar&eacute;.  Les op&eacute;rateurs binaires peuvent &ecirc;tre surcharg&eacute;s avec des types valides de donn&eacute;es, sauf pour les op&eacute;rateurs relationnels, qui doivent retourner <tt><a href="KeyPgInteger.html">Integer</a></tt>.<br \>
<br \>
<tt><a href="KeyPgLet.html">Let</a></tt> se r&eacute;f&egrave;re &agrave; l'op&eacute;rateur d'affectation, comme dans <tt>LET a=b</tt>. Le mot-cl&eacute; <tt><a href="KeyPgLet.html">Let</a></tt> est omis dans la pratique courante et n'est pas autoris&eacute; en dialecte <i><a href="CompilerOptlang.html">-lang fb</a></i>.  Toutefois, <tt><a href="KeyPgOpLetlist.html">Let()</a></tt> peut &ecirc;tre utilis&eacute; pour affecter des champs d'un type de donn&eacute;es utilisateur &agrave; des variables multiples.<br \>
<br \>
Voir <tt><a href="KeyPgOpFor.html">For</a></tt>, <tt><a href="KeyPgOpStep.html">Step</a></tt> et <tt><a href="KeyPgOpNext.html">Next</a></tt> pour plus d'informations sur la surcharge de la d&eacute;claration <tt><a href="KeyPgFornext.html">For..Next</a></tt> pour une utilisation avec des types d&eacute;finis par l'utilisateur.<br \>
<br \>
</div><div class="fb_sect_title">Exemple</div><div class="fb_sect_cont"><br \>
<tt><div class="freebasic">
<span class="key">Type</span>&nbsp;<span class="wrd">Vector2D</span><br />
&nbsp;&nbsp;<span class="key">As</span>&nbsp;<span class="key">Single</span>&nbsp;<span class="wrd">x</span><span class="oth">,</span>&nbsp;<span class="wrd">y</span><br />
<br />
&nbsp;&nbsp;<span class="com">''&nbsp;Return&nbsp;a&nbsp;string&nbsp;containing&nbsp;the&nbsp;vector&nbsp;data.</span><br />
&nbsp;&nbsp;<span class="key">Declare</span>&nbsp;<span class="key">Operator</span>&nbsp;<span class="key">Cast</span><span class="oth">()</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">String</span><br />
<span class="key">End</span>&nbsp;<span class="key">Type</span><br />
<br />
<span class="com">''&nbsp;Allow&nbsp;two&nbsp;vectors&nbsp;to&nbsp;be&nbsp;able&nbsp;to&nbsp;be&nbsp;added&nbsp;together.</span><br />
<span class="key">Declare</span>&nbsp;<span class="key">Operator</span>&nbsp;<span class="oth">+</span>&nbsp;<span class="oth">(</span>&nbsp;<span class="key">ByRef</span>&nbsp;<span class="wrd">lhs</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">Vector2D</span><span class="oth">,</span>&nbsp;<span class="key">ByRef</span>&nbsp;<span class="wrd">rhs</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">Vector2D</span>&nbsp;<span class="oth">)</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">Vector2D</span><br />
<br />
<span class="key">Operator</span>&nbsp;<span class="wrd">Vector2D.cast</span>&nbsp;<span class="oth">()</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">String</span><br />
&nbsp;&nbsp;<span class="key">Return</span>&nbsp;<span class="quo">"("</span>&nbsp;<span class="oth">+</span>&nbsp;<span class="key">Str</span><span class="oth">(</span><span class="wrd">x</span><span class="oth">)</span>&nbsp;<span class="oth">+</span>&nbsp;<span class="quo">",&nbsp;"</span>&nbsp;<span class="oth">+</span>&nbsp;<span class="key">Str</span><span class="oth">(</span><span class="wrd">y</span><span class="oth">)</span>&nbsp;<span class="oth">+</span>&nbsp;<span class="quo">")"</span><br />
<span class="key">End</span>&nbsp;<span class="key">Operator</span><br />
<br />
<span class="key">Operator</span>&nbsp;<span class="oth">+</span>&nbsp;<span class="oth">(</span>&nbsp;<span class="key">ByRef</span>&nbsp;<span class="wrd">lhs</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">Vector2D</span><span class="oth">,</span>&nbsp;<span class="key">ByRef</span>&nbsp;<span class="wrd">rhs</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">Vector2D</span>&nbsp;<span class="oth">)</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">Vector2D</span><br />
&nbsp;&nbsp;<span class="key">Return</span>&nbsp;<span class="key">Type</span><span class="oth">&lt;</span><span class="wrd">Vector2D</span><span class="oth">&gt;(</span>&nbsp;<span class="wrd">lhs.x</span>&nbsp;<span class="oth">+</span>&nbsp;<span class="wrd">rhs.x</span><span class="oth">,</span>&nbsp;<span class="wrd">lhs.y</span>&nbsp;<span class="oth">+</span>&nbsp;<span class="wrd">rhs.y</span>&nbsp;<span class="oth">)</span><br />
<span class="key">End</span>&nbsp;<span class="key">Operator</span><br />
<br />
<span class="key">Dim</span>&nbsp;<span class="wrd">a</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">Vector2D</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="key">Type</span><span class="oth">&lt;</span><span class="wrd">Vector2D</span><span class="oth">&gt;(</span>&nbsp;<span class="num">1.2</span><span class="oth">,</span>&nbsp;<span class="num">3.4</span>&nbsp;<span class="oth">)</span><br />
<span class="key">Dim</span>&nbsp;<span class="wrd">b</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">Vector2D</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="key">Type</span><span class="oth">&lt;</span><span class="wrd">Vector2D</span><span class="oth">&gt;(</span>&nbsp;<span class="num">8.9</span><span class="oth">,</span>&nbsp;<span class="num">6.7</span>&nbsp;<span class="oth">)</span><br />
<br />
<span class="key">Print</span>&nbsp;<span class="quo">"a&nbsp;=&nbsp;"</span><span class="oth">;</span>&nbsp;<span class="wrd">a</span><br />
<span class="key">Print</span>&nbsp;<span class="quo">"b&nbsp;=&nbsp;"</span><span class="oth">;</span>&nbsp;<span class="wrd">b</span><br />
<span class="key">Print</span>&nbsp;<span class="quo">"a&nbsp;+&nbsp;b&nbsp;=&nbsp;"</span><span class="oth">;</span>&nbsp;<span class="wrd">a</span>&nbsp;<span class="oth">+</span>&nbsp;<span class="wrd">b</span><br />
</div></tt><br />
</div><div class="fb_sect_title">Diff&eacute;rences de dialecte</div><div class="fb_sect_cont"><br \>
<ul><li> Disponible seulement dans le dialecte <i><a href="CompilerOptlang.html">-lang fb</a></i>.<br \>
<br \>
</ul></div><div class="fb_sect_title">Voir aussi</div><div class="fb_sect_cont"><br \>
<ul><li> <tt><a href="KeyPgClass.html">Class</a></tt><br \>
<li> <tt><a href="KeyPgClass.html">Enum</a></tt><br \>
<li> <tt><a href="KeyPgType.html">Type</a></tt><br \>
<br \>
</ul></div>
</div>
</div> 
</div> 
</body>
</html>
